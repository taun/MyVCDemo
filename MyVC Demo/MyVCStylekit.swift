//
//  MyVCStylekit.swift
//  MyVCDemo
//
//  Created by Taun Chapman on 09/10/17.
//  Copyright Â© 2017 (null). All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//
//  This code was generated by Trial version of PaintCode, therefore cannot be used for commercial purposes.
//



import UIKit

public class MyVCStylekit : NSObject {

    //// Cache

    private struct Cache {
        static let warningColor: UIColor = UIColor(red: 0.786, green: 0.599, blue: 0.000, alpha: 1.000)
        static let pastDueColor: UIColor = UIColor(red: 0.681, green: 0.025, blue: 0.025, alpha: 1.000)
        static let normalDueColor: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.860)
        static let myVCTint: UIColor = UIColor(red: 0.494, green: 0.046, blue: 0.943, alpha: 1.000)
        static let navBarColor: UIColor = UIColor(red: 0.343, green: 0.343, blue: 0.343, alpha: 1.000)
        static var imageOfTabBarContactsFilled: UIImage?
        static var tabBarContactsFilledTargets: [AnyObject]?
    }

    //// Colors

    @objc dynamic public class var warningColor: UIColor { return Cache.warningColor }
    @objc dynamic public class var pastDueColor: UIColor { return Cache.pastDueColor }
    @objc dynamic public class var normalDueColor: UIColor { return Cache.normalDueColor }
    @objc dynamic public class var myVCTint: UIColor { return Cache.myVCTint }
    @objc dynamic public class var navBarColor: UIColor { return Cache.navBarColor }

    //// Drawing Methods

    @objc dynamic public class func drawTabBarContactsFilled() {
        //// Color Declarations
        let template = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 7.5, y: 2, width: 10, height: 10))
        template.setFill()
        ovalPath.fill()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 21, y: 14))
        bezierPath.addLine(to: CGPoint(x: 22, y: 20))
        bezierPath.addCurve(to: CGPoint(x: 19, y: 23), controlPoint1: CGPoint(x: 22, y: 21.66), controlPoint2: CGPoint(x: 20.66, y: 23))
        bezierPath.addLine(to: CGPoint(x: 6, y: 23))
        bezierPath.addCurve(to: CGPoint(x: 3, y: 20), controlPoint1: CGPoint(x: 4.34, y: 23), controlPoint2: CGPoint(x: 3, y: 21.66))
        bezierPath.addLine(to: CGPoint(x: 4, y: 14))
        bezierPath.addCurve(to: CGPoint(x: 6.76, y: 11.01), controlPoint1: CGPoint(x: 4, y: 12.42), controlPoint2: CGPoint(x: 5.22, y: 11.13))
        bezierPath.addCurve(to: CGPoint(x: 12.5, y: 14), controlPoint1: CGPoint(x: 8.03, y: 12.82), controlPoint2: CGPoint(x: 10.13, y: 14))
        bezierPath.addCurve(to: CGPoint(x: 18.24, y: 11.01), controlPoint1: CGPoint(x: 14.87, y: 14), controlPoint2: CGPoint(x: 16.97, y: 12.82))
        bezierPath.addCurve(to: CGPoint(x: 21, y: 14), controlPoint1: CGPoint(x: 19.78, y: 11.13), controlPoint2: CGPoint(x: 21, y: 12.42))
        bezierPath.close()
        template.setFill()
        bezierPath.fill()
    }

    //// Generated Images

    @objc dynamic public class var imageOfTabBarContactsFilled: UIImage {
        if Cache.imageOfTabBarContactsFilled != nil {
            return Cache.imageOfTabBarContactsFilled!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 25, height: 25), false, 0)
            MyVCStylekit.drawTabBarContactsFilled()

        Cache.imageOfTabBarContactsFilled = UIGraphicsGetImageFromCurrentImageContext()!.resizableImage(withCapInsets: UIEdgeInsets.zero, resizingMode: .tile)
        UIGraphicsEndImageContext()

        return Cache.imageOfTabBarContactsFilled!
    }

    //// Customization Infrastructure

    @objc @IBOutlet dynamic var tabBarContactsFilledTargets: [AnyObject]! {
        get { return Cache.tabBarContactsFilledTargets }
        set {
            Cache.tabBarContactsFilledTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: MyVCStylekit.imageOfTabBarContactsFilled)
            }
        }
    }

}



private extension UIColor {
    func withHue(_ newHue: CGFloat) -> UIColor {
        var saturation: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(nil, saturation: &saturation, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: newHue, saturation: saturation, brightness: brightness, alpha: alpha)
    }
    func withSaturation(_ newSaturation: CGFloat) -> UIColor {
        var hue: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: nil, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: hue, saturation: newSaturation, brightness: brightness, alpha: alpha)
    }
    func withBrightness(_ newBrightness: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: nil, alpha: &alpha)
        return UIColor(hue: hue, saturation: saturation, brightness: newBrightness, alpha: alpha)
    }
    func withAlpha(_ newAlpha: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, brightness: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: nil)
        return UIColor(hue: hue, saturation: saturation, brightness: brightness, alpha: newAlpha)
    }
    func highlight(withLevel highlight: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-highlight) + highlight, green: green * (1-highlight) + highlight, blue: blue * (1-highlight) + highlight, alpha: alpha * (1-highlight) + highlight)
    }
    func shadow(withLevel shadow: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-shadow), green: green * (1-shadow), blue: blue * (1-shadow), alpha: alpha * (1-shadow) + shadow)
    }
}
